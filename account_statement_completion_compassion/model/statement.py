# -*- encoding: utf-8 -*-
##############################################################################
#
#    Copyright (C) 2014 Compassion CH (http://www.compassion.ch)
#    Releasing children from poverty in Jesus' name
#    @author: Emanuel Cino <ecino@compassion.ch>
#
#    The licence is in the file __openerp__.py
#
##############################################################################

from openerp.osv import orm, fields
from openerp.tools import mod10r
from openerp.tools.translate import _
from openerp import netsvc

from sponsorship_compassion.model.product import GIFT_CATEGORY, GIFT_NAMES, \
    SPONSORSHIP_CATEGORY

import time


class AccountStatement(orm.Model):

    """ Adds a relation to a recurring invoicer. """

    _inherit = 'account.bank.statement'

    _columns = {
        'recurring_invoicer_id': fields.many2one(
            'recurring.invoicer', 'Invoicer'),
    }

    def button_auto_completion(self, cr, uid, ids, context=None):
        invoicer = self.browse(cr, uid, ids[0], context).recurring_invoicer_id
        invoicer_obj = self.pool.get('recurring.invoicer')
        if invoicer:
            invoicer_id = invoicer.id
        else:
            invoicer_id = invoicer_obj.create(cr, uid, {}, context=context)
            self.write(
                cr, uid, ids, {'recurring_invoicer_id': invoicer_id},
                context=context)
            invoicer = invoicer_obj.browse(
                cr, uid, invoicer_id, context=context)

        super(AccountStatement, self).button_auto_completion(
            cr, uid, ids, context=context)

        if not invoicer.invoice_ids:
            invoicer_obj.unlink(cr, uid, invoicer_id, context=context)

    def button_invoices(self, cr, uid, ids, context=None):
        invoicer_id = self.browse(
            cr, uid, ids[0], context=context).recurring_invoicer_id.id

        return {
            'name': 'Generated Invoices',
            'view_mode': 'tree,form',
            'view_type': 'form',
            'res_model': 'account.invoice',
            'domain': [('recurring_invoicer_id', '=', invoicer_id)],
            'type': 'ir.actions.act_window',
            'target': 'current',
            'context': {'form_view_ref': 'account.invoice_form',
                        'journal_type': 'sale'},
        }

    def button_confirm_bank(self, cr, uid, ids, context=None):
        """Confirm invoices generated by statment lines."""
        res = super(AccountStatement, self).button_confirm_bank(cr, uid, ids,
                                                                context)
        wf_service = netsvc.LocalService('workflow')
        for statement in self.browse(cr, uid, ids, context):
            for line in statement.line_ids:
                if line.invoice_id:
                    # Validate the invoice
                    wf_service.trg_validate(
                        uid, 'account.invoice', line.invoice_id.id,
                        'invoice_open', cr)
        return res

    def button_cancel(self, cr, uid, ids, context=None):
        """ Cancel invoices generated by statement lines. """
        res = super(AccountStatement, self).button_cancel(cr, uid, ids,
                                                          context)
        invoice_obj = self.pool.get('account.invoice')
        for statement in self.browse(cr, uid, ids, context):
            invoice_ids = [l.invoice_id.id for l in statement.line_ids
                           if l.invoice_id]
            # Reset the invoices to draft state
            invoice_obj.action_cancel_draft(cr, uid, invoice_ids)
        return res


class AccountStatementLine(orm.Model):
    """ Adds products to statement lines to generate invoices. """

    _inherit = 'account.bank.statement.line'

    _columns = {
        'product_id': fields.many2one('product.product', _('Product')),
        'contract_id': fields.many2one('recurring.contract', _('Sponsorship')),
        'user_id': fields.many2one('res.partner', _('Ambassador')),
        'invoice_id': fields.many2one('account.invoice', 'Invoice'),
    }

    def create(self, cr, uid, vals, context=None):
        """Generate invoice if a product is selected."""
        res_id = super(AccountStatementLine, self).create(cr, uid, vals,
                                                          context)
        if 'product_id' in vals or 'contract_id' in vals:
            # Generate new invoices
            self._create_invoice_from_line(cr, uid, self.browse(
                cr, uid, res_id, {'lang': 'en_US'}), context)
        return res_id

    def write(self, cr, uid, ids, vals, context=None):
        """Generate invoice if a product is selected."""
        if 'product_id' in vals or 'contract_id' in vals:
            for line in self.browse(cr, uid, ids, context):
                # Remove old invoice
                invoice = line.invoice_id
                if invoice:
                    if not invoice.internal_number:
                        invoice.unlink()
                    else:
                        invoice.write({
                            'recurring_invoicer_id': False})
                    line.write({'invoice_id': False, 'ref': '/'})
        res = super(AccountStatementLine, self).write(cr, uid, ids, vals,
                                                      context)
        if 'product_id' in vals or 'contract_id' in vals:
            # Generate new invoices
            [self._create_invoice_from_line(cr, uid, line, context)
             for line in self.browse(cr, uid, ids, {'lang': 'en_US'})]
        return res

    def _create_invoice_from_line(self, cr, uid, b_line, context=None):
        if not b_line.product_id:
            return True
        # Get the attached recurring invoicer
        invoicer = b_line.statement_id.recurring_invoicer_id
        invoice_obj = self.pool.get('account.invoice')
        if not invoicer:
            invoicer_obj = self.pool.get('recurring.invoicer')
            invoicer_id = invoicer_obj.create(cr, uid, {'source': self._name},
                                              context)
            b_line.statement_id.write(
                {'recurring_invoicer_id': invoicer_id})
            invoicer = invoicer_obj.browse(cr, uid, invoicer_id, context)

        # Generate a unique bvr_reference
        ref = mod10r((b_line.date.replace('-', '') + str(
            b_line.statement_id.id) + str(b_line.id)).ljust(26, '0'))

        # Lookup for an existing open invoice matching the criterias
        invoice_ids = self._find_open_invoice(cr, uid, b_line, context)
        if invoice_ids:
            # Get the bvr reference of the invoice or set it
            invoice = invoice_obj.browse(cr, uid, invoice_ids[0], context)
            invoice.write({'recurring_invoicer_id': invoicer.id})
            if invoice.bvr_reference:
                ref = invoice.bvr_reference
            else:
                invoice.write({'bvr_reference': ref})
            b_line.write({
                'ref': ref,
                'invoice_id': invoice.id})
            return True

        # Setup a new invoice if no existing invoice is found
        journal_ids = self.pool.get('account.journal').search(
            cr, uid, [('type', '=', 'sale')], limit=1)
        payment_term_ids = self.pool.get('account.payment.term').search(
            cr, uid, [('name', '=', 'Bank Transfer')],
            context={'lang': 'en_US'})
        inv_data = {
            'account_id': b_line.partner_id.property_account_receivable.id,
            'type': 'out_invoice',
            'partner_id': b_line.partner_id.id,
            'journal_id': journal_ids[0] if journal_ids else False,
            'date_invoice': b_line.date,
            'payment_term': payment_term_ids and payment_term_ids[0] or 1,
            'bvr_reference': ref,
            'recurring_invoicer_id': invoicer.id,
            'currency_id': b_line.statement_id.currency.id,
        }
        if b_line.product_id.name == GIFT_NAMES[0] and b_line.contract_id \
                and b_line.contract_id.child_id and \
                b_line.contract_id.child_id.birthdate:
            inv_data['date_invoice'] = self.pool.get(
                'generate.gift.wizard').compute_date_birthday_invoice(
                b_line.contract_id.child_id.birthdate, b_line.date)
        invoice_id = invoice_obj.create(cr, uid, inv_data, context)

        inv_line_data = {
            'name': b_line.name,
            'account_id': b_line.product_id.property_account_income.id,
            'price_unit': b_line.amount,
            'price_subtotal': b_line.amount,
            'contract_id': b_line.contract_id and
            b_line.contract_id.id or False,
            'user_id': b_line.user_id and b_line.user_id.id or False,
            'quantity': 1,
            'uos_id': False,
            'product_id': b_line.product_id.id,
            'partner_id': b_line.partner_id.id,
            'invoice_id': invoice_id,
        }

        if b_line.product_id.categ_name in (GIFT_CATEGORY,
                                            SPONSORSHIP_CATEGORY) and not \
                b_line.contract_id:
            raise orm.except_orm(_('A field is required'),
                                 _('Add a Sponsorship'))

        if b_line.analytic_account_id:
            inv_line_data['account_analytic_id'] = \
                b_line.analytic_account_id.id
        else:
            analytic = self.pool.get('account.analytic.default').account_get(
                cr, uid, b_line.product_id.id, b_line.partner_id.id, uid,
                time.strftime('%Y-%m-%d'), context=context)
            if analytic and analytic.analytics_id:
                inv_line_data['analytics_id'] = analytic.analytics_id.id

        self.pool.get('account.invoice.line').create(
            cr, uid, inv_line_data, context)

        invoice_obj.button_compute(cr, uid, [invoice_id], context)
        b_line.write({
            'ref': ref,
            'invoice_id': invoice_id})

        return True

    def _find_open_invoice(self, cr, uid, b_line, context=None):
        """ Find an open invoice that matches the statement line and which
        could be reconciled with. """
        invoice_line_obj = self.pool.get('account.invoice.line')
        invl_ids = invoice_line_obj.search(cr, uid, [
            ('partner_id', '=', b_line.partner_id.id),
            ('state', 'in', ('open', 'draft')),
            ('product_id', '=', b_line.product_id.id),
            ('invoice_id.account_id', '=', b_line.account_id.id),
            ('price_subtotal', '=', b_line.amount)], context=context)
        return list(set([
            l.invoice_id.id for l in invoice_line_obj.browse(
                cr, uid, invl_ids, context)
            if l.invoice_id.amount_total == b_line.amount]))
