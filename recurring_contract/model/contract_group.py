# -*- encoding: utf-8 -*-
##############################################################################
#
#    Copyright (C) 2014 Compassion CH (http://www.compassion.ch)
#    Releasing children from poverty in Jesus' name
#    @author: Cyril Sester <csester@compassion.ch>, Steve Ferry
#
#    The licence is in the file __openerp__.py
#
##############################################################################

from datetime import datetime
from dateutil.relativedelta import relativedelta

from openerp import api, fields, models, _
from openerp.tools import DEFAULT_SERVER_DATE_FORMAT as DF
import logging
logger = logging.getLogger(__name__)


class contract_group(models.Model):
    _name = 'recurring.contract.group'
    _description = 'A group of contracts'
    _inherit = 'mail.thread'
    _rec_name = 'ref'

    ##########################################################################
    #                                 FIELDS                                 #
    ##########################################################################

    # TODO Add unit for advance_billing
    advance_billing_months = fields.Integer(
        'Advance billing months',
        help=_(
            'Advance billing allows you to generate invoices in '
            'advance. For example, you can generate the invoices '
            'for each month of the year and send them to the '
            'customer in january.'
        ), default=1, ondelete='no action')
    payment_term_id = fields.Many2one('account.payment.term',
                                      'Payment Term',
                                      track_visibility="onchange")
    next_invoice_date = fields.Date(
        compute='_set_next_invoice_date',
        string='Next invoice date', store=True)
    last_paid_invoice_date = fields.Date(
        compute='_set_last_paid_invoice',
        string='Last paid invoice date')

    change_method = fields.Selection(
        '_get_change_methods', default='do_nothing')
    partner_id = fields.Many2one(
        'res.partner', 'Partner', required=True,
        ondelete='cascade', track_visibility="onchange")
    ref = fields.Char('Reference', default="/")
    recurring_unit = fields.Selection([
        ('day', _('Day(s)')),
        ('week', _('Week(s)')),
        ('month', _('Month(s)')),
        ('year', _('Year(s)'))], 'Reccurency',
        default='month', required=True)
    recurring_value = fields.Integer(
        'Generate every', default=1, required=True)
    contract_ids = fields.One2many(
        'recurring.contract', 'group_id', 'Contracts', readonly=True)

    ##########################################################################
    #                             FIELDS METHODS                             #
    ##########################################################################
    @api.depends('contract_ids.next_invoice_date', 'contract_ids.state')
    @api.one
    def _set_next_invoice_date(self):
        next_inv_date = min(
            [c.next_invoice_date for c in self.contract_ids
             if c.state in self._get_gen_states()] or [False])
        self.next_invoice_date = next_inv_date

    @api.multi
    def _set_last_paid_invoice(self):
        for group in self:
            group.last_paid_invoice_date = max(
                [c.last_paid_invoice_date for c in group.contract_ids] or
                [False])

    ##########################################################################
    #                              ORM METHODS                               #
    ##########################################################################

    @api.multi
    def write(self, vals):
        """
            Perform various check at contract modifications
            - Advance billing increased or decrease
            - Recurring value or unit changes
            - Another change method was selected
        """
        res = True
        # to solve "NotImplementedError: Iteration is not allowed" error
        # Any of these modifications implies generate and validate invoices
        generate_again = ('advance_billing_months' in vals or
                          'recurring_value' in vals or
                          'recurring_unit' in vals)

        for group in self:

            # Check if group has an next_invoice_date
            if not group.next_invoice_date:
                res = super(contract_group, self).write(vals) and res
                break

            # Get the method to apply changes
            change_method = vals.get('change_method', group.change_method)
            change_method = getattr(self, change_method)

            res = super(contract_group, self).write(vals) & res

            if generate_again:
                change_method()

        if generate_again:
            invoicer_id = self.generate_invoices()
            self.validate_invoices(invoicer_id)

        return res

    ##########################################################################
    #                              ORM METHODS                               #
    ##########################################################################

    @api.multi
    def button_generate_invoices(self):
        invoicer = self.generate_invoices()
        self.validate_invoices(invoicer)
        return invoicer

    @api.one
    def validate_invoices(self, invoicer):
        # Check if there is invoice waiting for validation
        if invoicer.invoice_ids:
            invoicer.validate_invoices()

    ##########################################################################
    #                             PUBLIC METHODS                             #
    ##########################################################################

    def clean_invoices(self):
        """ Change method which cancels generated invoices and rewinds
        the next_invoice_date of contracts, so that new invoices can be
        generated taking into consideration the modifications of the
        contract group.
        """
        since_date = datetime.today()
        if self.last_paid_invoice_date:
            last_paid_invoice_date = datetime.strptime(
                self.last_paid_invoice_date, DF)
            since_date = max(since_date, last_paid_invoice_date)
        res = self.contract_ids.clean_invoices(
            since_date=since_date.strftime(DF))
        self.contract_ids.rewind_next_invoice_date()
        return res

    def do_nothing(self):
        """ No changes before generation """
        pass

    def generate_invoices(self, invoicer=None):
        """ Checks all contracts and generate invoices if needed.
        Create an invoice per contract group per date.
        """
        logger.info("Invoice generation started.")
        inv_obj = self.env['account.invoice']
        journal_obj = self.env['account.journal']
        gen_states = self._get_gen_states()
        if not invoicer:
            invoicer = self.env['recurring.invoicer'].create(
                {'source': self._name})

        journal_ids = journal_obj.search(
            [('type', '=', 'sale'), ('company_id', '=', 1 or False)], limit=1)

        nb_groups = len(self)
        count = 1
        for contract_group in self:
            logger.info("Generating invoices for group {0}/{1}".format(
                count, nb_groups))
            month_delta = contract_group.advance_billing_months or 1
            limit_date = datetime.today() + relativedelta(months=+month_delta)
            while True:  # Emulate a do-while loop
                # contract_group update 'cause next_inv_date has been modified
                group_inv_date = contract_group.next_invoice_date
                contracts = []
                if group_inv_date and datetime.strptime(group_inv_date,
                                                        DF) <= limit_date:
                    contracts = [c
                                 for c in contract_group.contract_ids
                                 if c.next_invoice_date <= group_inv_date and
                                 c.state in gen_states]
                if not contracts:
                    break
                inv_data = contract_group._setup_inv_data(journal_ids,
                                                          invoicer)
                invoice = inv_obj.create(inv_data)
                for contract in contracts:
                    contract_group._generate_invoice_lines(contract, invoice)
                if invoice.invoice_line:
                    invoice.button_compute()
                else:
                    invoice.unlink()

            # After a contract_group is done, we commit all writes in order to
            # avoid doing it again in case of an error or a timeout
            self.env.cr.commit()
            count += 1
        logger.info("Invoice generation successfully finished.")
        return invoicer

    ##########################################################################
    #                             PRIVATE METHODS                            #
    ##########################################################################
    @api.multi
    def _get_change_methods(self):
        """ Method for applying changes """
        return [
            ('do_nothing',
             'Nothing'),
            ('clean_invoices',
             'Clean invoices')
        ]

    def _get_gen_states(self):
        return ['active']

    def _setup_inv_data(self, journal_ids, invoicer):
        """ Setup a dict with data passed to invoice.create.
            If any custom data is wanted in invoice from contract group, just
            inherit this method.
        """
        partner = self.partner_id
        inv_data = {
            'account_id': partner.property_account_receivable.id,
            'type': 'out_invoice',
            'partner_id': partner.id,
            'journal_id': len(journal_ids) and journal_ids[0].id or False,
            'currency_id':
            partner.property_product_pricelist.currency_id.id or False,
            'date_invoice': self.next_invoice_date,
            'recurring_invoicer_id': invoicer.id,
            'payment_term': self.payment_term_id and
            self.payment_term_id.id or False,
        }

        return inv_data

    @api.multi
    def _setup_inv_line_data(self, contract_line, invoice):
        """ Setup a dict with data passed to invoice_line.create.
        If any custom data is wanted in invoice line from contract,
        just inherit this method.
        """
        product = contract_line.product_id
        account = product.property_account_income
        inv_line_data = {
            'name': product.name,
            'price_unit': contract_line.amount or 0.0,
            'quantity': contract_line.quantity,
            'uos_id': False,
            'product_id': product.id or False,
            'invoice_id': invoice.id,
            'contract_id': contract_line.contract_id.id,
        }
        if account:
            inv_line_data['account_id'] = account.id
        return inv_line_data

    @api.multi
    def _generate_invoice_lines(self, contract, invoice):
        inv_line_obj = self.env['account.invoice.line']
        for contract_line in contract.contract_line_ids:
            inv_line_data = self._setup_inv_line_data(contract_line, invoice)
            if inv_line_data:
                inv_line_obj.create(inv_line_data)

        if not self.env.context.get('no_next_date_update'):
            contract.update_next_invoice_date()
